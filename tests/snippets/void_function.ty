package main;

type struct { x: int, y: int } Point;
type struct { pt1: Point, pt2: Point } Line;
type struct { height: int, width: int, depth: int } Rect ;

def abyss() -> void {
  return;
}

def vanish(x: int, y: double) -> void {
  return;
}

def doAssign(data: int) -> int {
  let newVal = data ;
  return newVal ;
}

def assignMultiply() -> int {
  let calc = 3 * 9 ;
  return calc ;
}

def arithMultiGroup(first : int, second : int) -> int {
  let calc = (first + 6) * (second + 5) + 1;
  return calc ;
}

def returnCalcResult(first : int, second : int) -> int {
  return (first + 6) + 2 *(second + 5);
}

def retBool(x : int, y : int) -> bool {
  let isLessThan = x < y; 
  return isLessThan;
}

def one() -> int {
  return 1;
}

def floor_zero(x : int, y : int) -> int {
  if x < 0 {
    return 0;
  }

  return x;
}

def either_or(x : int, y : int) -> int {
  if x < 0 {
    return x;
  } else {
    return y;
  }

  return 0;
}

def if_elif_else_chain(x : int, y : int) -> int {
  if x == 0 {
    return 1;
  } elif y == 0 {
    return 2;
  } elif x > 1 {
    return 3;
  } elif y == 1 {
    return 4;
  } else {
    return 7;
  }

  return 0;
}

def pow(num : int, exp: int) -> int {
  if exp == 0 {
    return 1;
  }

  let mut total = 1;
  let mut counter = exp;
  while counter > 0 {
    total = total * num;
    counter = counter - 1;
  }
  return total;
}

def rise(line: Line) -> int {
  let y1 = line.pt1.y;
  let y2 = line.pt2.y;
  return y2 - y1;
}

def newLine(x1: int, y1: int, x2: int, y2: int) -> Line {
  let point2 = Point{x: x2, y: y2};
  let line = Line{pt1: Point{x: x1, y: y1}, pt2: point2};
  return line;
}

def swap(pt: Point) -> Point {
  let tmpX = pt.x;
  pt.x = pt.y;
  pt.y = tmpX;
  return pt;
}

def make_point() -> int {
  let point = Point{ x: 3, y: 5};

  return point.y;
}

def fibonacci(n: int) -> int {
  if n <= 2 {
    return 1;
  }

  let n_minus_1 = n - 1;
  let n_minus_2 = n - 2;

  return fibonacci(n_minus_1) + fibonacci(n_minus_2);
}

def fib_iter(n: int) -> int {

  let mut n_minus_1 = 1;
  let mut n_minus_2 = 1;
  let mut result = 1;

  let mut cnt = 3;
  while cnt <= n {
    let tmp = n_minus_1 + n_minus_2;
    result = tmp;

    n_minus_2 = n_minus_1;
    n_minus_1 = tmp;
    cnt = cnt + 1;
  }

  return result;
}

def nested_arith_parens_1(y: int) -> int {
  let x = (3 + (1 + 1))*(y + (3*2)) / 2;
  return x;
}

def nested_arith_parens_2(y: int) -> int {
  let x =  (( ( (3 + (1 + 1))*(y + (3*2)) / 2 ) ));
  return x;
}